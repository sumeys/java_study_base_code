##### 垃圾收集算法

1. 标记--清除算法（老年代）

   ```
   首先标记出所有需要被回收的对象，标记完成之后统一回收
   不足之处：1，标记清除两个过程效率都不高
   		2，标记清除之后会产生大量的不连续的碎片
   ```

2. 复制算法( 老年代不宜使用,一般用来回收新生代)

   ```
   将内存划分为等大的两块区域，每次只使用其中的一块，当一块内存用完了，就将存活着的对象复制到另一块上面，然后再把已经使用过的内存一次性清理掉
   代价就是造成了严重的内存浪费，因此现代的jvm实现是：
   *将内存分为较大的Eden和两块较小的Survivor部分，每次使用Eden+1Survivor，回收时，把这次使用的部门一次性复制到另一块Survivor上面。ps：当内存不足时，以来其他内存如老年代进行分配担保。
   ```

3. 标记--整理算法(针对老年代)

   ```
   过程与标记清除一样，只是后续不是直接对可回收对象进行清理，而是让所有的存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
   ```

4. 分代收集算法

   ```
   现代jvm所采用
   一般把java堆划分老年代和新生代，对新生代采取复制算法，对老年代采取标记清除或标记整理算法。
   ```



##### 内存分配策略

1. 优先在新生代的eden区域分配

2. 大对象直接进入老年代

3. 长期存活的对象直接进入老年代(对象的年龄默认为15，有个阈值，但是并非总是如此，当Survivor空间中所有相同年龄的对象大小总和大于Survivor空间的一半，年龄大于该年龄的对象就可以直接进入老年代)

   ps：新生代GC(Minor GC，频繁，速度快)   老年代GC（Full GC，比MGC慢10倍以上）



##### 几种溢出情况

1. Java堆溢出

   不断的创建对象，就可以产生OOM，分为内存泄漏和内存溢出两种情况。

2. 方法区和运行时常量区溢出

   可以产出大量的常量以及运行时产生大量的类去填满方法区。

3. 程序计数器占很小的一块区域，而且jvm规范也没有规定OutOfMemoryError情况，一般不予考虑。

4. 虚拟机栈和本地方法栈溢出

   两种异常:  (1).如果线程请求的栈深度大于虚拟机所允许的最大深度，将产生StackOverflowError的异常（单线程中出现，无论增大本地变量表还是减少栈内存的大小）

   ```
   	（2).如果虚拟机在扩展栈时无法申请到足够的空间，抛出OutOfMemoryError的异常（多线程时候出现）。
   ```





##### 几种垃圾收集器

   先说Hot Spot（sun公司）的几种实现特点

1. 枚举根节点

   采用可达性分析算法时，必须要停顿来保证此时的引用关系不会发生变化。

   HotSpot通过OopMap的数据结构来知道哪些地方存在对对象的引用。

2. 安全点（SavePoint）

   程序执行在安全点的时候暂停然后开始GC，一般以让程序长时间执行为标准来进行选取。

   为了保证所有的程序都跑到最近的安全点上停顿下来，有两种方案：

   ```
   a.抢先式中断：先把所有的线程都中断，发现有的不在安全点上，就回复线程，让它跑到安全点上。——一般不采用这种方式
   
   b.主动式中断：GC需要中断的时候，先简单的设置一个标志，各个线程去轮询这个标志，为true的时候就把自己中断挂起，轮询标志的地方和安全点地方是重合的。
   ```

3. 安全区域（Save Region，这个区域引用关系不会发生变化，任何地方GC都是安全的）

   主要是来解决当程序不执行时，如sleep或block的时候，无法走到安全点把自己中断。当程序执行到安全域的时候，首先标志自己，这个时候jvm发起GC的时候，就不用管在安全域的线程了，当程序离开安全域的时候，先检查系统是否完成了枚举根节点，否则就会等待直到可以离开安全域的信号为止。

   ***Serial收集器( 用于新生代，复制算法)***

   单线程收集器，在进行GC时，必须暂停其他所有的工作线程。

   ***ParNew( 新生代复制)***

   是serial的多线程版本

   ***Parallel Scavenge(新生代复制)***

   与parNew的区别是它更关注吞吐量，即运行用户代码时间/总时间的比值

   ***Serial Old收集器( 老年代，标记整理)***



   ***Parallel Old(老年代，标记整理)***



   ***CMS收集器(老年代，标记清除)***

   四步骤：1. 初始标记(stop the world)：仅标记一下GC ROOTS可达的对象，速度很快

   		2.并发标记：较长，GC Roots Trancing过程

   		3.重新标记(stop the world)：修正因并发标记引起的对象引用关系的变动

   		4.并发清除：较长

   缺点：1.对CPU资源非常敏感，会因占用CPU资源导致变慢

   	    2.无法清除浮动垃圾：即这次GC的同时新产生的垃圾，只能下一次GC的时候再进行收集。

   	    3.标记清除产生的碎片问题

   ***G1收集器***

   特点：

   	1.并发与并行

   	2.分代收集

   	3.空间整合

   	4.可预测的停顿：能让用户自己指定在M时间内，消耗在垃圾收集上的不超过N

   过程：初始标记，并发标记，最终标记，筛选回收

