### 线程安全和锁

##### java语言的线程安全

1. 不可变：即变量为final类型
2. 绝对线程安全：不论运行环境如何，调用者都不需要额外的同步措施，Java中线程安全的类，绝大部份都不是绝对的线程安全
3. 相对线程安全：对对象单独的操作是线程安全的，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的手段来保证调用的正确性。
4. 线程兼容：对象本身并不是线程安全的，但是可以通过调用端正确的使用同步手段来保证对象在并发环境中可以安全使用。
5. 线程对立：无论调用端是否采取了同步措施，都无法在多线程环境中并发的进行。

##### 线程安全的实现方法

1. 互斥同步

   synchronized关键字和ReentrantLock

   基本用法很相似，都具备一样的线程重入特性，代码写法上有区别，一个表现为API层面的互斥锁（lock和unlock方法配合try/finally语句块来完成），另一个表现为原生语法层面的互斥锁。

   synchronized关键字经过编译之后，会在同步块的前后形成monitorenter和monitorexit两个字节码指令；**synchronized同步块对同一条线程来说是可重入的，不会出现把自己锁死的问题；同步块在已进入的线程执行完毕之前，会阻塞后面其他线程的进入**

    ReentrantLock增加了一些高级性能：**1，等待可中断：当持有锁的对象长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他的事情   2，可实现公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序依次获得锁，非公平锁不保证这一点，syn和ree默认都是非公平的，但可以通过带默认值的构造函数来要求使用公平锁    3，锁绑定多个条件：一个ReentrantLock对象可以同时绑定多个condition对象，通过多次调用newCondition()方法即可；但是对于syn来说，锁对象的wait()，notify()和notifyAll()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不实现额外的添加一个锁**

   性能区别：在jdk1.6之前，多线程条件下syn性能下降的非常快，而ree基本上能稳定在一个水平上，jdk1.6之后，进行了优化，性能不再是选择的考虑因素，所以提倡在syn能实现需求的情况下，优先选取syn来实现同步。

##### 几种锁优化

1.自旋锁与自适应自旋

自旋锁：物理机器上有两个或以上的服务器，能让两个线程并行，我们可以让后面请求锁的那个线程自旋（做空循环，等待锁释放）一下，因为挂起和恢复线程都需要转入内核态中完成，比较耗费性能。

自适应自旋：自旋的时间不在固定，以前默认为10次，会根据前一次同一个锁上的自旋时间以及锁的拥有者的状态来确定。

1. 锁消除

java即时编译器(JIT)在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

1. 锁粗化

虚拟机检测到一串零碎的操作都对同一个对象加锁，就会把加锁同步的范围粗化到整个操作序列之外。

1. 轻量级锁

通过对对象的内存部分的修改来实现的

1. 偏向锁

这个锁会偏向第一个获取它的线程，如果接下来该锁没有被其他线程获取，则持有偏向锁的线程永远不需要再进行同步。

